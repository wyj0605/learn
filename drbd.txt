 HA集群之DRBD浅析及实现DRBD高可用
2014-05-12 22:04:25
标签：
原创作品，允许转载，转载时请务必以超链接形式标明文章 原始出处 、作者信息和本声明。否则将追究法律责任。http://hoolee.blog.51cto.com/7934938/1410121
一、DRBD概述
   DRBD (Distributed Replicated Block Device) 是 Linux 平台上的分散式储存系统。
   由内核模组、用户空间工具组成，通常用于高可用性（high availability, HA）集群。其实现方式是通过网络在服务器之间的对块设备（硬盘，分区，逻辑卷等）进行镜像。你可以把它看作是一种网络RAID1。
   DRBD的工作模式如下图：
wKiom1NvRCyjER_hAAF1PGQOynA147.jpg
       DRBD工作的位置在文件系统的buffer cache和磁盘调度器之间，数据进入Buffer Cache后，DRBD复制一份数据，交给TCP/IP协议栈封装，然后发送到另一个节点上，另一个节点接受到TCP/IP协议报文后解封装，将数据交给DRBD，再由对方的DRBD存储在本地对应磁盘 上。这样主节点数据与备节点数据可以保证实时同步。当主节点出现故障时，备节点上还会保留有一份相同的数据，可供使用。在高可用(HA)集群中中使用DRBD，可以代替一个共享盘阵。
       DRBD工作在系统内核空间，它直接复制的二进制数据，故速度很快。
       DRBD，由Linux内核架构支撑，因此，不能添加了上层所具备的一些新特性。例如，DRBD技术不能自动检测文件系统损坏。
    对于用户来说，一个DRBD设备，就像是一块物理的磁盘，可以在上面内创建文件系统。DRBD需要在底层设备之上构建出一个块设备。DRBD所支持的底层设备包括磁盘(或是磁盘的一个分区)、soft raid 设备、LVM的逻辑卷等块设备。

二、DRBD特性
一般只能做主从，主的资源为设primary，能不受限制进行读写操作，可以创建文件系统，可以使用裸设备,甚至直接io；从的的资源设为secondary连挂载都不能，并且只能一个主节点，一个从节点，不能一主多从，正是因为这样在集群中只能有一个节点可以随时操作数据，这种模式可用在任何的文件系统上（EXT3、EXT4、XFS等等）。
DRBD8.0之后支持双主模式。在双主模式下，任何资源在任何特定的时间，集群中都存在两个主节点。由于双方数据存在并发的可能性，这种模式需要一个共享的集群文件系统(如GFS和OCFS2)，利用分布式的锁机制进行管理。部署双主模式时，DRBD是负载均衡的集群，需要从两个并发的主节点中选取一个首选的访问数据。这种模式默认是禁用的，如果要是用的话必须在配置文件中进行声明。
DRBD本身没有故障转移能力，当主节点挂了，需要借助高可用集群服务来把保证故障转移(fail-over)的能力，将从提升为主。
DRDB本身没有探测对方是否宕机的方法,需要借助高可用集群服务来实现此功能。

三、DRBD数据同步模式
异步：当数据写到磁盘上，并且复制的数据已经被放到本地的tcp缓冲区等待发送以后，就认为写入完成。(在一个节点发生故障时，可能发生数据丢失，因为被写入到远程节点上的数据可能仍在发送队列。尽管，在故障转移节点上的数据是一致的，但没有及时更新。这通常是用于地理上分开的节点。)
半同步：当数据已经写到磁盘上，并且复制的数据已经被放到对端的tcp缓冲区等待写入，就认为写入完成。(数据丢失可能发生在参加的两个节点同时故障的情况下，因为在飞行中的数据可能不会被提交到磁盘。)
同步： 本地和对端的磁盘都已经确认了写操作完成，写入才被认为完成。(没有任何数据丢失，所以这是一个群集节点的流行模式，但I/O吞吐量依赖于网络带宽。)
 DRBD 的复制模型是靠protocol关键字来定义的：protocol A表示异步；protocol B表示半同步；protocol C表示同步，默认为protocol C。

四、DRBD脑裂(split brain)
   split brain实际上是指在某种情况下，造成DRBD的两个节点断开连接，都以primary的身份来运行。当DRBD某primary节点连接对方节点准备发送信息的时候，如果发现对方也是primary状态，那么会立刻自行断开连接，并认定当前已经发生split brain，这时候会在系统日志中记录以下信息：“Split-Brain detected,dropping connection!”当发生split brain之后，如果查看连接状态，其中至少会有一个是StandAlone状态，另外一个可能也是StandAlone（如果是同时发现split brain状态），也有可能是WFConnection的状态。
对于脑裂,DRBD有四中处理方式:
新成为主节点的把数据丢弃,再同步老节点的数据
把老的主节点的数据丢弃,再同步新节点的数据
谁的数据修改的少,谁主动丢弃数据
如果有个节点从没发生过数据修改,那就不用动
       自动裂脑自动修复能不能被接受取决于对数据丢失的容忍性。例如，财务的数据库对于任何修改的丢失都是不能容忍的，这 表示不管在什么情况下都需要手工修复裂脑问题。因此，是否启用裂脑自动修复需要考虑具体情况。

五、metadata
   DRBD将数据的各种信息块保存在一个专用的区域里，这些metadata包括DRBD设备的大小、产生的标识、活动日志、快速同步的位图。
   metadata的存储方式有内部和外部两种方式，使用方式可以在资源配置中定义。
1.内部(internal)：metadata存放在同一块硬盘或分区的最后的位置上
优点：metadata和数据是在一起，如果硬盘损坏，metadata同样就没有了，但在恢复的时候，metadata也会一起被恢复回来
缺点：metadata和数据在同一块硬盘上，磁盘I/O负载大。因为写请求会触发metadata的更新，每一次写操作就会造成两次磁头读写移动。
2.外部(external)：metadata存放在和数据磁盘分开的独立的块设备上
优点：写操作更流畅
缺点：metadata和数据不在一起，所以如果数据盘出现故障，在更换新盘的时候就需要人为的干预来进行新硬盘的同步。

六、DRBD的版本
       Linux内核2.6.33以后，DRBD内核模块代码直接被整合进Linux内核中，使用DRBD只需安装用户空间管理工具。
       在kernel 2.6.33以前的版本版本中，需要同时安装内核模块和用户空间管理工具。
       内核模块程序包版本必须要系统内核保持匹配，使用uname -r查看内核版本，然后使用相对应的内核模块。
       用户空间管理工具就不那么严格要求。

七、DRBD配置工具和配置文件
1.配置工具
drbdadm：户空间的工具，管理/etc/drbd.conf，向drbdsetup和drbdmeta发送指令。
drbdsetup：配置装载进kernel的DRBD模块，很少直接用。
drbdmeta：管理META数据结构，一般是修复DRDB时才使用。
2.配置文件
    DRBD的主配置文件为/etc/drbd.conf；为了管理的便捷性，目前通常会将些配置文件分成多个部分，且都保存至/etc/drbd.d目录中，主配置文件中仅使用"include"指令将这些配置文件片断整合起来。
       /etc/drbd.d目录中的配置文件为global_common.conf和所有以.res结尾的文件。
       global_common.conf中主要定义global段和common段。global段必须位于配置文件的最开始处，可以定义的参数仅有minor-count, dialog-refresh, disable-ip-verification和usage-count。。common段则用于定义被每一个资源默认继承的参数，common段并非必须，但建议将多个资源共享的参数定义为common段中的参数以降低配置文件的复杂度。
       每一个.res的文件用于定义一个资源，内里有一个resource段，包含：
Resource name：可以是除了空白字符的任意的ACSII码字符
DRBD device：在双方节点上，此DRBD设备的设备文件；一般为/dev/drbdN，其主设备号147
Disk configuration：在双方节点上，各自提供的存储设备
Nerwork configuration：双方数据同步时所使用的网络属性
   每一个资源段的定义中至少要包含两个host子段，以定义此资源关联至的节点，其它参数均可以从common段或drbd的默认中进行继承。

八、安装配置DRBD
1.安装DRBD
   node1/node2均安装
//确定内核版本
# uname -r
//安装与版本对应的内核模块和用户空间管理工具
# yum -y install drbd-8.4.3-33.el6.x86_64.rpm drbd-kmdl-2.6.32-431.el6-8.4.3-33.el6.x86_64.rpm
2.配置DRBD
       node1
[root@node1 ~]# vim /etc/drbd.conf     //查看主配置文件
# You can find an example in  /usr/share/doc/drbd.../drbd.conf.example
include "drbd.d/global_common.conf";
include "drbd.d/*.res";


//修改全局配置文件
# vim /etc/drbd.d/global_common.conf
global {   //全局配置
        usage-count no;  #让linbit公司收集目前drbd的使用情况，yes为参加，我们这里不参加设置为no
        # minor-count dialog-refresh disable-ip-verification
}
common {
        handlers {    #处理器
                # These are EXAMPLE handlers only.
                # They may have severe implications,
                # like hard resetting the node under certain circumstances.
                # Be careful when chosing your poison.
                pri-on-incon-degr "/usr/lib/drbd/notify-pri-on-incon-degr.sh; /usr/lib/drbd/notify-emergency-reboot.sh; echo b > /proc/sysrq-trigger ; reboot -f";
                // 定义了如果主节点降级了怎么处理的
                pri-lost-after-sb "/usr/lib/drbd/notify-pri-lost-after-sb.sh; /usr/lib/drbd/notify-emergency-reboot.sh; echo b > /proc/sysrq-trigger ; reboot -f";
                //这个定义了如果有脑裂了之后找不到主节点怎么处理的
                local-io-error "/usr/lib/drbd/notify-io-error.sh; /usr/lib/drbd/notify-emergency-shutdown.sh; echo o > /proc/sysrq-trigger ; halt -f";
                //定义了一旦本地节点发生IO错误时应该怎么处理
                # fence-peer "/usr/lib/drbd/crm-fence-peer.sh";
                # split-brain "/usr/lib/drbd/notify-split-brain.sh root";
                # out-of-sync "/usr/lib/drbd/notify-out-of-sync.sh root";
                # before-resync-target "/usr/lib/drbd/snapshot-resync-target-lvm.sh -p 15 -- -c 16k";
                # after-resync-target /usr/lib/drbd/unsnapshot-resync-target-lvm.sh;
        }
        startup {    //定义一个节点启动时另一个节点应该怎么做         
                # wfc-timeout    //等待另一个节点上线的超时时长
                # degr-wfc-timeout   //等待超时后做降级处理
                # outdated-wfc-timeout  //过期的等待超时
                # wait-after-sb   //脑裂之后等待多长时长
        }
        options {
                # cpu-mask on-no-data-accessible
        }
        disk {
                on-io-error detach;  #同步错误的做法是分离
                # size max-bio-bvecs on-io-error fencing disk-barrier disk-flushes
                # disk-drain md-flushes resync-rate resync-after al-extents
                # c-plan-ahead c-delay-target c-fill-target c-max-rate
                # c-min-rate disk-timeout
        }
        net {
                protocol C;
                cram-hmac-alg "sha1";  #设置加密算法sha1
                shared-secret "mydrbd";  #设置加密key
                # protocol timeout max-epoch-size max-buffers unplug-watermark
                # connect-int ping-int sndbuf-size rcvbuf-size ko-count
                # allow-two-primaries cram-hmac-alg shared-secret after-sb-0pri
                # after-sb-1pri after-sb-2pri always-asbp rr-conflict
                # ping-timeout data-integrity-alg tcp-cork on-congestion
                # congestion-fill congestion-extents csums-alg verify-alg
                # use-rle
        }
        syncer {    # 同步相关的设置
                rate 1000M; #设置重新同步(re-synchronization)速度
        #re-synchronization时候，如果有大量不一致的数据，
        #我们不可能将所有带宽都分配给drbd做re- synchronization，
        #这样会影响对外提提供服务。rate的设置需要考虑IO能力。
        #一般来说，设置网络IO能力和磁盘IO能力中最小者的30%的带宽给re- synchronization是比较合适的（官方说明）
        # drbd还提供了一个临时的rate更改命令，可以临时性的更改syncer的rate 值：
        #drbdsetup /dev/drbd0 syncer -r 100M
        #这样就临时的设置为100M。
        #结束之后，通过
        #drbdadm adjust resource_name 来让drbd按照配置中的rate工作。
        }
}

3.为节点准备磁盘分区
   node1/node2都需要准备，分好区不需要格式化，系统能识别就行可
# fdisk /dev/sda    //具体不详述
# kpart -af /dev/sda
# partx  -a /dev/sda   //一次识别不出来，可以多重复几次
       顺便同步时间，均设置
1
2
# crontab -e
*/5 * * * * /usr/sbin/ntpdate  172.16.0.1 &> /dev/null

4.定义资源

# cd /etc/drbd.d/
# vim mystore.res
resource mystore {            #定义一个资源，用关键字resource；
  on node1.hoo.com {          #on说明在哪个节点上，跟uname -n保持一致
    device    /dev/drbd0;     #在磁盘上表现的drbd叫什么名；
    disk      /dev/sda5;      #所使用的磁盘设备是哪个；
    address   172.16.1.11:7789;  #监听的套接字,默认监听在7789端口上；
    meta-disk internal;         #内部存放metadata
  }
  on node2.hoo.com {
    device    /dev/drbd0;
    disk      /dev/sda5;
    address   172.16.1.12:7789;
    meta-disk internal;
  }
}
5.同步配置文件
1
# scp global_common.conf mystore.res node2:/etc/drbd.d/

6.初始化资源
   node1/node2均初始化
1
# drbdadm create-md mystore

7.启动DRBD服务
       node1/node2均启动
1
# service drbd start

8.查看启动状态

5
//以下两种方式均可查看
# cat /proc/drbd
或
# drbd-overview
//初始化后，两个节点均处于Secondary状态

9.选择主节点
        将node1提升为主节点
1
[root@node1 ~]# drbdadm primary --force mystore
    观察
1
2
# drbd-overview
//两节点开始同步数据

10.格式化并挂载
1
2
3
[root@node1 ~]# mke2fs  -t ext4 /dev/drbd0
[root@node1 ~]# mkdir /drbd
[root@node1 ~]# mount /dev/drbd0 /drbd

11.测试

//复制文件到DRBD设备
[root@node1 ~]# cd /drbd/
[root@node1 drbd]# cp /etc/inittab /drbd/
//角色转换，将node1降级
[root@node1 ~]# drbdadm secondary mystore 
//将node2提升为主
[root@node2 ~]# drbdadm primary mystore
[root@node2 ~]# mkdir /drbd
[root@node2 ~]# mount /dev/drbd0 /drbd
[root@node2 ~]# cd /drbd
[root@node2 ~]# ls
                //inittab文件存在




九、corosync结合pacemaker，实现DRBD高可用
1.搭建集群
   a).配置主机名
      节点名称很关键，集群每个节的名称都得能互相解析。/etc/hosts中的主机名配置结果必须跟”uname -n”的解析的结果一致。
      node1/node2都添加：

node1示例：
# vim /etc/hosts
172.16.1.11 node1.hoo.com node1
172.16.1.12 node2.hoo.com node2
# ifconfig eth0 172.16.1.11  up
# hostname node1.hoo.com
# uname -n
# vim /etc/sysconfig/network  //重启才生效，source也不生效
hostname=node1.hoo.com
   b).配置node之间SSH互信
node1:
#ssh-keygen  -t rsa -f ~/.ssh/id_rsa  -P ''
# ssh-copy-id -i .ssh/id_rsa.pub root@node2.hoo.com
node1:
#ssh-keygen  -t rsa -f ~/.ssh/id_rsa  -P ''
# ssh-copy-id -i .ssh/id_rsa.pub root@node1.hoo.com
node1：测试
#  ssh node2.hoo.com ‘date’;date
   c).安装corosync和pacemaker
  所有节点均安装
1
2
3
4
5
# yum install corosync pacemaker -y
# rpm -ql corosync
//配置目录：/etc/corosync
//配置模板：/etc/corosync/corosync.conf.example
//服务器脚本：/etc/rc.d/init.d/corosync

   d).安装资源管理器客户端命令接口工具crmsh
 从pacemaker 1.1.8开始，crmsh发展成了一个独立项目，叫crmsh。pacemaker默认不提供命令接口工具，需要单独安装crmsh。
1
2
3
//crmsh依赖pssh
# yum -y install pssh-2.3.1-2.el6.x86_64.rpm
# yum -y install crmsh-1.2.6-4.el6.x86_64.rpm
   e).配置主配置文件
[root@node1 ~]# cd /etc/corosync/
[root@node1 corosync]# cp corosync.conf.example corosync.conf
[root@node1 corosync]# vi corosync.conf
compatibility: whitetank   #表示是否兼容0.8之前的版本
totem {        #图腾，定义集群中各节点中通信机制以及参数
version: 2    #图腾的协议版本号，不修改
secauth: on   #安全认证功能是否启用，当使用aisexec时，会非常消耗CPU
threads: 0    #实现认证时的并行线程数，0表示默认配置
interface {   # 指定在哪个接口发心跳信息，子模块
ringnumber: 0   #冗余环号，节点有多个网卡是可定义，避免心跳信息成环。
bindnetaddr: 192.168.1.0   #绑定心跳网段
mcastaddr: 226.94.8.8      #心跳组播地址
mcastport: 5405            #心跳组播使用端口
ttl: 1                     #表示只向外播一次
}
}
logging {          # 跟日志相关
fileline: off       #指定要打印的行
to_stderr: no       #是否发送到标准错误输出，即屏幕
to_logfile: yes#记录到日志文件
to_syslog: no       #记录到系统日志syslog
logfile: /var/log/cluster/corosync.log  #日志文件路径
debug: off          #是否启动调试
timestamp: on       #是否打印时间戳
logger_subsys {     #日志的子系统
subsys: AMF
debug: off
}
}
service {
ver:  0
name: pacemaker        #定义corosync启动时同时启动pacemaker
# use_mgmtd: yes
}
aisexec {     #表示启动ais的功能时，以哪个用户的身份运行
#这个块可不定义，corosync默认就是以root身份运行的
user: root
group: root
}
amf {     # 跟编程接口相关的
mode: disabled
}

   f).生成认证key
  用corosync-keygen生成key时，由于要使用/dev/random生成随机数，因此如果新装的系统操作不多，如果没有足够的熵，狂敲键盘即可，随意敲，敲够即可。（关于random使用键盘敲击产生随机数的原理可自行google）
  实验演示没有足够的熵，这里将采用投机的方式，生产环境，切切不可。

//投机的认证方式
# mv /dev/random /dev/lala
# ln /dev/urandom /dev/random   //将随机数生成器链接至伪随机数生成器
# corosync-keygen    //生成密钥文件，用于节点通信，会生成authkey文件
# rm -rf /dev/random        //删除链接
# mv /dev/lala /dev/random     //还原随机数生成器
   g).copy配置给node2
1
[root@node1 corosync]# scp authkey corosync.conf node2:/etc/corosync/
   h).启动corosync
1
2
[root@node1 corosync]# service corosync start
[root@node1 corosync]# ssh node2  "service corosync start"
   i).检查启动情况

//查看corosync引擎是否正常启动
[root@node1 corosync]# grep -e "Corosync Cluster Engine" -e "configuration file" /var/log/messages
//查看初始化节点通知是否正常发出
[root@node1 corosync]# grep  TOTEM  /var/log/messages
//检查启动过程中是否有错误产生
[root@node1 corosync]# grep ERROR: /var/log/messages | grep -v unpack_resources
//查看pacemaker是否正常启动
[root@node1 corosync]# grep pcmk_startup /var/log/messages


2.实现DRBD高可用
a).关闭drbd并设置开机不启动
   node1/node2均设置

# service drbd stop
# chkconfig drbd off
# chkconfig drbd --list
b).添加drbd资源

[root@node1 ~]# crm
crm(live)# configure
crm(live)configure# property stonith-enabled=false    //禁用stonith
crm(live)configure# property no-quorum-policy=ignore  //双节点设置忽略
crm(live)configure# rsc_defaults resource-stickiness=100 //资源粘性
crm(live)configure# verify
crm(live)configure# commit
crm(live)configure# show
crm(live)configure# meta ocf:linbit:drbd   //查看drbd的详细信息
crm(live)configure# primitive drbdstore ocf:linbit:drbd params drbd_resource=mystore op monitor role=Master interval=30s timeout=20s op monitor role=Slave interval=60s timeout=20s op start timeout=240s op stop timeout=100s
            //定义资源
crm(live)configure# verify
crm(live)configure# master ms_drbdstore drbdstore meta master-max=1 master-node-max=1 clone-max=2 clone-node-max=1 notify=”True”
            //定义主资源
crm(live)configure# verify
crm(live)configure# commit


c).添加文件系统资源
       定义文件系统资源，让服务器切换时自动挂载

crm(live)configure# primitive drbdfs ocf:heartbeat:Filesystem params device=/dev/drbd0 directory=/drbd fstype=ext4 op monitor interval=30s timeout=40s on-fail-restart op start timeout=60 op stop timeout=60
crm(live)configure# verify
crm(live)configure# commit

d).定义约束

//定义排列约束：
# collocation drbdfs_with_ms_drbdstore_master inf: drbdfs ms_drbdstore:Master
        //drbd与文件系统在一起
# verify
//定义顺序约束：
# order drbdfs_after_ms_drbdstore_master mandatory: ms_drbdstore:promote drbdfs:start
# show
# commit
e).测试

//查看节点状态
crm(live)# status
            //显示node2为主
//验证挂载：
[root@node2 drbd]#ls
    //显示: inittab  lost+found
//手动改变节点的主从
crm(live)# node standby node2.hoo.com   把node2降级为备用
//node1验证挂载信息
[root@node1 drbd]#ls

